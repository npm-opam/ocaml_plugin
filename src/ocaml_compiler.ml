open Core.Std
open Async.Std
open Import

let tar_id = "dynlink.tgz"
;;

let ocamlopt_opt = "ocamlopt.opt"
let ocamldep_opt = "ocamldep.opt"
let camlp4o_opt  = "camlp4o.opt"
let ppx_exe      = "ppx.exe"
;;

let pervasives  = "pervasives.cmi"
let config_file = "config.sexp"
;;

let persistent_archive_subdir = "compiler"
;;

let mandatory_embedded_files =
  [ ocamlopt_opt
  ; pervasives
  ]
;;

module Config = struct
  (* Attempt to have maximum backward and forward compatibility mode for apps that allow
     the use of a persistent archive *)
  module Syntax = struct
    type t =
      { pa_files           : string list                       [@default []]
      ; camlp4_is_embedded : [`pa_files of string list] option [@default None]
      ; ppx_is_embedded    : bool                              [@default false]
      }
    [@@deriving sexp]

    let t_of_sexp =
      Sexp.of_sexp_allow_extra_fields t_of_sexp
    ;;
  end

  type t =
    { camlp4_is_embedded : [`pa_files of string list] option
    ; ppx_is_embedded    : bool
    }

  include Sexpable.Of_sexpable (Syntax)
      (struct
        type nonrec t = t
        let of_sexpable ({ Syntax.
                           pa_files
                         ; camlp4_is_embedded
                         ; ppx_is_embedded
                         } as syntax) =
          { camlp4_is_embedded =
              begin match camlp4_is_embedded with
              | None ->
                begin match pa_files with
                | [] -> None
                | _ :: _ -> Some (`pa_files pa_files)
                end
              | Some (`pa_files pa_files') ->
                begin match pa_files with
                | []   -> ()
                | _ :: _ ->
                  if 0 <> [%compare: string list] pa_files pa_files'
                  then failwiths "invalid config file" syntax [%sexp_of: Syntax.t];
                end;
                camlp4_is_embedded
              end
          ; ppx_is_embedded
          }
        ;;

        let to_sexpable { camlp4_is_embedded
                        ; ppx_is_embedded
                        } =
          { Syntax.
            camlp4_is_embedded
          ; ppx_is_embedded
          ; pa_files =
              begin match camlp4_is_embedded with
              | None -> []
              | Some (`pa_files pa_files) -> pa_files
              end
          }
        ;;
      end)
end

(* Map of the directories contents:
   - build_dir: /tmp/ocaml_plugin_XXXXX/{m_dyn_1_.ml,m_dyn_1_.o,m_dyn_1_.cmx,m_dyn_1_.cmxs,...}
     Deleted on clean up.
   - compiler_dir:
       Either /tmp/ocaml_plugin_XXXXX/{ocamlopt.opt,pervasives.cmi,pa_sexp_conv.cmo,...}
       or $user_specified_dir/compiler/{archive-info.sexp,the other files}.
       Locked if it is shared using $user_specified_dir/compiler.lock. Deleted on clean up
       if they are the same directory otherwise deleted when the digest of the archive
       doesn't match the info anymore.
   - cache dir:
       $user_specified_dir/cmxs-cache/{cache-info.sexp, abcd-efgh-ijkl-mnop.cmxs}
       copied there from build_dir
       Locked because it can be shared using $user_specified_dir/cmxs-cache.lock.
   Both locks are released on clean up. *)

module Archive_lock = struct
  type t =
  | Cleaned
  | Cleaning of unit Deferred.Or_error.t
  | Locked of string
end

type t =
  { loader       : Ocaml_dynloader.t
  ; archive_lock : Archive_lock.t ref
  }
[@@deriving fields]

let clean t =
  Ocaml_dynloader.clean t.loader >>= fun r1 ->
  (match t.archive_lock.contents with
  | Archive_lock.Cleaned -> Deferred.Or_error.ok_unit
  | Archive_lock.Cleaning def -> def
  | Archive_lock.Locked lock_filename ->
    let clean = Lock_file.Nfs.unlock lock_filename in
    t.archive_lock.contents <- Archive_lock.Cleaning clean;
    clean >>| fun res ->
    t.archive_lock.contents <- Archive_lock.Cleaned;
    res)
  >>| fun r2 ->
  Or_error.combine_errors_unit
    [ r1
    ; r2
    ]
;;

(* This external declaration should be implemented by the c files generated by
   ocaml_embed_compiler.exe, which is normally called when using an "embed" entry
   in the jbuild. There is a default implementation in ocaml_fake_archive.c too. *)
external archive : unit -> Bigstring.t = "ocaml_plugin_archive"
let archive () =
  let bstr = archive () in
  let dummy = "dummy" in
  if Bigstring.length bstr = String.length dummy &&
     Bigstring.to_string bstr = dummy then
    None
  else
    Some bstr
;;

external archive_digest_binding : unit -> string = "ocaml_plugin_archive_digest"
let archive_digest () =
  Plugin_cache.Digest.of_string (archive_digest_binding ())
;;

let () =
  match Core.Std.Sys.getenv "OCAML_PLUGIN_DUMP_ARCHIVE" with
  | None -> ()
  | Some _ ->
    (* This is a way of extracting the archive from the executable. It can be used like
       this: OCAML_PLUGIN_DUMP_ARCHIVE= ./run.exe | tar -xz
       We exit to avoid running any side effects that could be done later at toplevel. *)
    Core.Std.Printf.eprintf "archive digest: %s\n%!"
      (Plugin_cache.Digest.to_string (archive_digest ()));
    begin match archive () with
    | None -> Core.Std.Printf.printf "No archive\n%!"
    | Some bstr -> Bigstring.really_output stdout bstr; Out_channel.flush stdout
    end;
    Core.Caml.Pervasives.exit 0
;;

let save_archive_to destination =
  Deferred.Or_error.try_with (fun () ->
    match archive () with
    | None -> failwith "There is no embedded compiler in the current executable"
    | Some contents -> Writer.with_file_atomic destination ~f:(fun w ->
      Writer.schedule_bigstring w contents;
      Deferred.unit)
  )
;;

exception Mandatory_file_not_found of string * string list [@@deriving sexp]
;;

(* Because the directory is empty before check_mandatory_files is called (modulo the
   archive itself), it can return the contents of the archive simply by reading everything
   in the directory (assuming the archive doesn't contain directories). *)
let check_mandatory_files working_dir =
  let fct () =
    Sys.readdir working_dir
    >>| function content_of_working_dir ->
    let files = Array.to_list content_of_working_dir in
    let iter file =
      if not (List.mem ~equal:String.equal files file)
      then raise (Mandatory_file_not_found (file, files))
    in
    List.iter ~f:iter mandatory_embedded_files;
    files
  in
  Deferred.Or_error.try_with ~extract_exn:true fct
;;

module Code_style = struct
  type t =
    [ `No_preprocessing
    | `Camlp4_style
    | `Ppx_style
    ]
  [@@deriving sexp]

  let of_string_alist =
    [ "camlp4"           , `Camlp4_style
    ; "ppx"              , `Ppx_style
    ; "no-preprocessing" , `No_preprocessing
    ]
  ;;

  let doc =
    sprintf "(%s)"
      (of_string_alist
       |> List.map ~f:fst
       |> String.concat ~sep:"|")
  ;;

  let arg_type = Command.Arg_type.of_alist_exn of_string_alist
  let optional_param =
    Command.Spec.(
      flag "-code-style" (optional arg_type)
        ~doc:(sprintf "%s Specify plugin code style" doc))
  ;;
end

type 'a create_arguments = (
  ?code_style:Code_style.t
  -> ?persistent_archive_dirpath:string
  -> 'a
) Ocaml_dynloader.create_arguments

module Plugin_archive : sig
  val extract :
    archive_lock:Archive_lock.t ref
    -> persistent:bool
    -> string
    -> unit Deferred.Or_error.t
end = struct
  module Digest = Plugin_cache.Digest
  module Info = struct
    type t =
      { infos          : (string * Sexp.t) list
      ; build_info     : Sexp.t
      ; archive_digest : Digest.t
      }
    [@@deriving sexp]

    let t_of_sexp = Sexp.of_sexp_allow_extra_fields t_of_sexp

    let info_file_name = "archive-info.sexp"
    let info_file dir = dir ^/ info_file_name
    ;;

    let create () =
      Deferred.Or_error.try_with ~extract_exn:true (fun () ->
        Unix.getlogin () >>| fun login ->
        [ "version"  , sexp_of_string Params.version
        ; "login"    , sexp_of_string login
        ; "hostname" , sexp_of_string (Unix.gethostname ())
        ; "sys_argv" , [%sexp_of: string array] Sys.argv
        ]
      ) >>|? fun infos ->
      let archive_digest = archive_digest () in
      let build_info = Params.build_info_as_sexp in
      { infos
      ; build_info
      ; archive_digest
      }
    ;;

    let info_file_perm = 0o644
    ;;

    let save dir =
      create () >>=? fun t ->
      Deferred.Or_error.try_with ~extract_exn:true (fun () ->
        Writer.save_sexp ~perm:info_file_perm (info_file dir) (sexp_of_t t)
      )
    ;;

    let load dir =
      Deferred.Or_error.try_with ~extract_exn:true (fun () ->
        Reader.load_sexp_exn (info_file dir) t_of_sexp
      )
    ;;

    let is_up_to_date t =
      Digest.compare (archive_digest ()) t.archive_digest = 0
    ;;
  end

  let extract_throttle = Throttle.Sequencer.create ~continue_on_error:true ()
  ;;

  let extract ~archive_lock ~persistent compiler_dir =
    let extract () =
      if_ persistent (fun () ->
        let lock_filename = compiler_dir ^ ".lock" in
        Monitor.try_with_or_error (fun () ->
          Unix.mkdir ~p:() ~perm:0o755 (Filename.dirname lock_filename)) >>=? fun () ->
        Lock_file.Nfs.create lock_filename >>=? fun () ->
        archive_lock := Archive_lock.Locked lock_filename;
        (* Beware of race condition in here. If we are killed in the middle of rm -rf, but
           the info file has not been deleted, then the extracted archive would be
           corrupted because it doesn't match the info file anymore.  This is why we first
           delete the info file, then delete everything else. *)
        Shell.rm       ~f:() [ Info.info_file compiler_dir ] >>=? fun () ->
        Shell.rm ~r:() ~f:() [ compiler_dir ] >>=? fun () ->
        Monitor.try_with_or_error (fun () ->
          Unix.mkdir ~p:() ~perm:0o755 compiler_dir)
      ) >>=? fun () ->
      let destination = compiler_dir ^/ tar_id in
      save_archive_to destination >>=? fun () ->
      Tar.extract ~working_dir:compiler_dir destination >>=? fun () ->
      if_ persistent (fun () -> Info.save compiler_dir)
    in
    if persistent
    then Throttle.enqueue extract_throttle (fun () ->
      Info.load compiler_dir >>= function
      | Ok info when Info.is_up_to_date info -> Deferred.Or_error.ok_unit
      | Ok _ | Error _ -> extract ()
    )
    else
      extract ()
  ;;
end

let create
    ?in_dir
    ?include_directories
    ?custom_warnings_spec
    ?strict_sequence
    ?cmx_flags
    ?cmxs_flags
    ?trigger_unused_value_warnings_despite_mli
    ?use_cache
    ?run_plugin_toplevel
    ?code_style
    ?persistent_archive_dirpath
    () =
  let archive_lock = ref Archive_lock.Cleaned in
  (match persistent_archive_dirpath with
  | None     -> Deferred.return (Ok None)
  | Some path ->
    Shell.absolute_pathname path >>|? fun path ->
    Some (path ^/ persistent_archive_subdir)
  ) >>=? fun persistent_archive_dirpath ->
  let in_compiler_dir exec =
    Option.value persistent_archive_dirpath ~default:"." ^/ exec
  in
  let include_directories =
    match persistent_archive_dirpath with
    | None -> include_directories
    | Some dir -> Some (dir :: Option.value include_directories ~default:[])
  in
  let ocamlopt_opt = in_compiler_dir ocamlopt_opt in
  let ocamldep_opt = in_compiler_dir ocamldep_opt in
  let nostdlib flags = "-nostdlib" :: Option.value ~default:[] flags in
  let cmx_flags = nostdlib cmx_flags in
  let cmxs_flags = nostdlib cmxs_flags in
  let preprocessor (config_opt : Config.t option) =
    let no_preprocessing = Ocaml_dynloader.Preprocessor.No_preprocessing in
    let camlp4 pa_files =
      Ocaml_dynloader.Preprocessor.Camlp4
        { camlp4o_opt = in_compiler_dir camlp4o_opt
        ; pa_files
        }
    in
    let ppx =
      Ocaml_dynloader.Preprocessor.Ppx { ppx_exe = in_compiler_dir ppx_exe }
    in
    match code_style, config_opt with
    | None, None -> Ok no_preprocessing
    | None, Some { camlp4_is_embedded; ppx_is_embedded } ->
      if ppx_is_embedded
      then Ok ppx
      else
        begin match camlp4_is_embedded with
        | Some (`pa_files pa_files) -> Ok (camlp4 pa_files)
        | None -> Ok no_preprocessing
        end

    | Some `No_preprocessing, _ -> Ok no_preprocessing

    | Some `Camlp4_style, (None | Some {camlp4_is_embedded = None; _ }) ->
      Or_error.error_string "There is no embedded camlp4o_opt in the current executable"

    | Some `Camlp4_style, Some {camlp4_is_embedded = Some (`pa_files pa_files); _ } ->
      Ok (camlp4 pa_files)

    | Some `Ppx_style, (None | Some {ppx_is_embedded = false; _}) ->
      Or_error.error_string "There is no embedded ppx_exe in the current executable"

    | Some `Ppx_style, Some {ppx_is_embedded = true; _} -> Ok ppx
  in
  let initialize_compilation_config ~directory:build_dir =
    let persistent, compiler_dir =
      match persistent_archive_dirpath with
      | None                 -> false, build_dir
      | Some archive_dirpath -> true,  archive_dirpath
    in
    Plugin_archive.extract ~archive_lock ~persistent compiler_dir >>=? fun () ->
    check_mandatory_files compiler_dir >>=? fun files ->
    begin
      if List.mem files config_file
      then
        Deferred.Or_error.try_with ~extract_exn:true (fun () ->
          Reader.load_sexp_exn (compiler_dir ^/ config_file) Config.t_of_sexp
          >>| Option.some
        )
      else Deferred.return (Ok None)
    end
    >>=? fun config_opt ->
    return (preprocessor config_opt)
    >>|? fun preprocessor ->
    { Ocaml_dynloader.Compilation_config.
      preprocessor
    }
  in
  Ocaml_dynloader.create
    ?in_dir
    ?include_directories
    ?custom_warnings_spec
    ?strict_sequence
    ~cmx_flags
    ~cmxs_flags
    ?trigger_unused_value_warnings_despite_mli
    ?use_cache
    ?run_plugin_toplevel
    ~initialize_compilation_config
    ~ocamlopt_opt
    ~ocamldep_opt
    ()
  >>=? fun loader ->
  let compiler =
    { loader
    ; archive_lock
    }
  in
  Deferred.return (Ok (`this_needs_manual_cleaning_after compiler))
;;

let created_but_not_cleaned = Bag.create ()
;;

let () =
  (* I think we can rely on the at_shutdown handlers only firing in the current process
     and not in the forks. In that case, worse things could happen than deleting the
     compiler under our feet. *)
  Shutdown.at_shutdown (fun () ->
    Deferred.List.iter (Bag.to_list created_but_not_cleaned) ~f:(fun compiler ->
      clean compiler >>| function
      | Ok ()   -> ()
      | Error _ -> ()
    )
  )
let shutting_down () =
  match Shutdown.shutting_down () with
  | `No    -> false
  | `Yes _ -> true
;;

exception Shutting_down [@@deriving sexp]
;;

let with_compiler
    ?in_dir
    ?include_directories
    ?custom_warnings_spec
    ?strict_sequence
    ?cmx_flags
    ?cmxs_flags
    ?trigger_unused_value_warnings_despite_mli
    ?use_cache
    ?run_plugin_toplevel
    ?code_style
    ?persistent_archive_dirpath
    ~f
    ()
    =
  if shutting_down () then Deferred.Or_error.of_exn Shutting_down else begin
    create
      ?in_dir
      ?include_directories
      ?custom_warnings_spec
      ?strict_sequence
      ?cmx_flags
      ?cmxs_flags
      ?trigger_unused_value_warnings_despite_mli
      ?use_cache
      ?run_plugin_toplevel
      ?code_style
      ?persistent_archive_dirpath
      ()
    >>=? function `this_needs_manual_cleaning_after compiler ->
    if shutting_down ()
    then
      clean compiler >>=? fun () ->
      Deferred.Or_error.of_exn Shutting_down
    else begin
      let bag_elem = Bag.add created_but_not_cleaned compiler in
      Deferred.Or_error.try_with_join ~extract_exn:true (fun () -> f compiler)
      >>= fun result ->
      Bag.remove created_but_not_cleaned bag_elem;
      clean compiler >>| fun r2 ->
      match result, r2 with
      | Ok result, Ok ()          -> Ok result
      | Ok _, (Error _ as error)  -> error
      | Error e1, Error e2        -> Error (Error.of_list [e1; e2])
      | Error _ as error, Ok ()   -> error
    end
  end
;;

let make_load_ocaml_src_files load_ocaml_src_files =
  let aux
      ?in_dir
      ?include_directories
      ?custom_warnings_spec
      ?strict_sequence
      ?cmx_flags
      ?cmxs_flags
      ?trigger_unused_value_warnings_despite_mli
      ?use_cache
      ?run_plugin_toplevel
      ?code_style
      ?persistent_archive_dirpath
      files =
    let f compiler =
      let loader = loader compiler in
      load_ocaml_src_files loader files
    in
    with_compiler
      ?in_dir
      ?include_directories
      ?custom_warnings_spec
      ?strict_sequence
      ?cmx_flags
      ?cmxs_flags
      ?trigger_unused_value_warnings_despite_mli
      ?use_cache
      ?run_plugin_toplevel
      ?code_style
      ?persistent_archive_dirpath
      ~f
      ()
  in
  aux
;;

let make_check_plugin_cmd
      ~check_ocaml_src_files
      ~load_ocaml_src_files
      ~with_code_style_switch () =
  let execute_plugin_toplevel_switch = "-execute-plugin-toplevel" in
  let arg_spec =
    Command.Spec.(
      empty
      +> anon (sequence ("path/to/plugin.ml" %: file))
      +> flag execute_plugin_toplevel_switch no_arg
           ~doc:" Run the plugin's toplevel to check for runtime errors"
      +> flag "-ocamldep" no_arg
           ~doc:" Use ocamldep. Expect only the main file in the remaining arguments"
      +> flag "-verbose" no_arg
           ~doc:" Be more verbose"
      +>
      if with_code_style_switch
      then Code_style.optional_param
      else return None
    )
  in
  let main plugin_filenames execute_plugin_toplevel use_ocamldep is_verbose code_style
        () =
    let f compiler =
      let loader = loader compiler in
      (if use_ocamldep
       then
         (match plugin_filenames with
          | [ main ] -> Ocaml_dynloader.find_dependencies loader main
          | [] | _ :: _ :: _ ->
            return
              (Or_error.error "Give only the main file when using option -ocamldep"
                 plugin_filenames [%sexp_of: string list]))
       else return (Ok plugin_filenames)
      ) >>=? fun plugin_filenames ->
      if is_verbose then
        Print.printf "checking: %s\n%!" (String.concat ~sep:" " plugin_filenames);
      if execute_plugin_toplevel
      then
        load_ocaml_src_files loader plugin_filenames
        >>| Or_error.map ~f:ignore
      else
        check_ocaml_src_files loader plugin_filenames
    in
    with_compiler ?code_style ~f ()
    >>| function
    | Ok () ->
      if is_verbose then Print.printf "ok\n%!";
      Shutdown.shutdown 0
    | Error err ->
      Print.eprintf "%s\n%!" (Error.to_string_hum err);
      Shutdown.shutdown 1
  in
  Command.async ~summary:"Check a plugin for compilation errors"
    ~readme:(fun () -> String.concat [ "\
This command checks that a plugin compiles.  It either succeeds quietly, or outputs
compilation errors and fails.

When it is deemed safe to execute the toplevel of a plugin, one can supply the switch
[" ; execute_plugin_toplevel_switch ; "] to check for runtime exceptions at toplevel." ])
    arg_spec
    main
;;

module type S = sig
  type t

  val load_ocaml_src_files : (
    string list -> t Deferred.Or_error.t
  ) create_arguments

  val check_ocaml_src_files : (
    string list -> unit Deferred.Or_error.t
  ) create_arguments

  val check_plugin_cmd :
    with_code_style_switch:bool
    -> unit
    -> Command.t

  module Load : Ocaml_dynloader.S with type t := t
end

module Make (X:Ocaml_dynloader.Module_type) = struct
  module Load = Ocaml_dynloader.Make(X)
  let load_ocaml_src_files  = make_load_ocaml_src_files Load.load_ocaml_src_files
  let check_ocaml_src_files = make_load_ocaml_src_files Load.check_ocaml_src_files
  ;;

  let check_plugin_cmd =
    make_check_plugin_cmd
      ~check_ocaml_src_files:Load.check_ocaml_src_files
      ~load_ocaml_src_files:Load.load_ocaml_src_files
  ;;
end

module Side_effect = struct
  module Load = Ocaml_dynloader.Side_effect
  let load_ocaml_src_files = make_load_ocaml_src_files Load.load_ocaml_src_files
  let check_ocaml_src_files = make_load_ocaml_src_files Load.check_ocaml_src_files
  ;;

  let check_plugin_cmd =
    make_check_plugin_cmd
      ~check_ocaml_src_files:Load.check_ocaml_src_files
      ~load_ocaml_src_files:Load.load_ocaml_src_files
  ;;
end
